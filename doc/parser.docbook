<?xml version="1.0"  encoding="UTF-8" ?>

<chapter id="parser">
<title>Introduction</title>
<para>
The new parser was introduced in Kommander with version 1.2, released with 
KDE 3.4. This document was originally released to show all the features of new parser. 
As of Kommander 1.3, released with KDE 3.5.9, the new parser is now the default. Because 
the new parser is so much richer in ability, overcomes the limitations of nesting in the 
old parser and adds so many new features we strongly recommend using it.
</para>
<para>
Kommander itself will not be described here. Please refer to other documents to 
see what is Kommander for, how to create dialogs and how to manipulate widgets
on runtime.
</para>
</chapter>



<chapter id="two_parsers">
<title>New parser vs. old parser</title>

<sect1 id="old_parser">
<title>Old parser</title>
<para>
The old parser was in fact macro parser. Only strings beginning with &#064; were 
recognized, locally parsed and expanded.
<screen>
@LineEdit1.setText(@ListBox.selection)
</screen>
</para>

<para>
All the underlying functionality (local variables, expressions, file manipulation) 
had to be done in another scripting langage, such as Bash. While the intent with Kommander is to support
all other scripting languages, and this is presently possible to some degree, there
was a need for a fast, native scripting language that was assured to be portable. 
The developers considered bash slow and not friendly to new users, and the old parser 
had been initially bash calling DCOP. The paradox for Kommander being language neutral
resulted in a need to do more than just functions natively.
</para>
</sect1>

<sect1 id="new_parser">
<title>New parser</title>
<para>
The new parser is a full parser. It parses the whole script, not just functions. As we were interested 
in GUI interaction, not the proliferation of scripting langages, we made compromises.
As a result you should find Kommander's scripting to be capable for most basic tasks
and natural and easy to use. There is also the <emphasis>Function Browser</emphasis>, which will help you 
assemble statements. The Function Browser is intended to make Kommander accessible to complete novice 
programmers. It is similar to what you would find in KSpread to help you choose a function
and fill in the paramters. 
<tip>If you want enhanced functionality found in other languages you can include
them in Kommander script objects headed with a sheebang. While in these scripts the Function
Broswer will help you insert references to widgets. Just remember when using this functionality 
that the parser makes one pass for the old parser functions and one pass for your script. So if you 
try to change something in a widget and read it in the middle of a script you may not get what you expect.</tip>
<screen>
#!/usr/bin/php
</screen>
It is also possible to make Kommander scripts executable with a sheebang at the top of the script.
<screen>
#!/usr/bin/kommander
</screen>
It is recommended to create a symlink if you want to use this so we know it is portable 
from system to system.
</para>
<para>The following feature list is from version 1.2</para>
<itemizedlist>
<listitem>local and global variables and associative arrays</listitem>
<listitem>numerical expressions</listitem>
<listitem>string manipulation</listitem>
<listitem>various structure commands: if, while, for, foreach</listitem>
<listitem>most functions from old parser</listitem>
<listitem>direct widget manipulation</listitem>
<listitem>many additional functions</listitem>
<listitem>decent execution speed</listitem>
<listitem>receive parameters from signals in script slots</listitem>
</itemizedlist>
<para>This list is from version 1.3</para>
<itemizedlist>
<listitem>pass parameters and receive them with script execute calls</listitem>
<listitem>return a value from a script</listitem>
<listitem>create widgets on the fly</listitem>
<listitem>connect signals and slots on the fly</listitem>
<listitem>use a variable alias for a widget name</listitem>
<listitem>simple indexed array functions</listitem>
<listitem>directly access a widgets slots</listitem>
</itemizedlist>
</sect1>

<sect1 id="invoking">
<title>Invoking new parser</title>
<para>
To enable new parser, set <command>useInternalParser</command> property of the dialog to
<command>true</command>. You can also enable new parser in a single script by putting
<screen>
#!kommander
</screen>
on the first line of the script. Also note if you are using another scripting language in 
a script with a sheebang that Kommander automatically enables the old parser for interacting 
with the dialog.
<screen>
#!/bin/bash
echo @Self.item(0)
# returns first paramter passed to script
# echo $returnvalue passes back to calling script
</screen>
</para>
</sect1>
</chapter>

<chapter id="features">
<title>Parser features</title>

<sect1 id="types">
<title>Types</title>
<para>
Each value is of one of three types: string, integer or double. Type conversion is 
automatic and chooses most appropriate type (for example, if you add double to integer,
result will be double). If one of the values is string, result will be string too.
</para>
<para>Places you can get into trouble here are getting a numerical value from a widget
and trying to perform a mathematical function on it. Since Kommander uses <command>+</command> 
to concatonate two strings of text it can treat <command>LineEdit1.text + 2</command> as 
<command>22</command> instead of <command>2</command>. See the conversion funtions in 
<link linkend="string_functions">String functions</link> to avoid problems.
</para>
</sect1>

<sect1 id="expressions">
<title>Expressions</title>
<para>
The following mathematical operators are supported: <command>+, -, *, mod, </command>. Standard brackets 
are of course supported as well.
</para>

<para>
All kinds of comparisons are supported: <command>&le;</command>, <command>&ge;</command>, <command>&le;=</command>, 
<command>&ge;=</command>, <command>==</command>, <command>!=</command>. Instead of
<command>!=</command> you can also use <command>&le;&ge;</command>. 
Also, logical operators <command>and</command>, <command>or</command>, <command>not</command> 
are supported, as well as their C equivalents (<command>&amp;&amp;</command>, <command>||</command>, <command>!</command>).
</para>

<para>
For strings you can use <command>+</command> operator for string concatenation.
</para>

<para>
Some examples of valid expressions:
<screen>
2+3
-5 * (2 - 13 mod 3)
"This list has " + 12 + "items."
</screen>
</para>
</sect1>

<sect1 id="variables">
<title>Variables</title>
<para>
Variables don't need to be declared. Once you use variable, it is considered declared. 
<link linkend="types">Type</link> of a variable is recognized automatically and can be changed later.
</para>

<para>
Assocative arrays are supported as well. They map string keys onto values of any type. To declare
such array, you can just add some element to it, for example: <command>A["Quanta"] = "Web editor"</command>.
Arrays are also handled by <link linkend="foreach">foreach </link> command and 
<link linkend="array_functions">array functions</link>.
</para>

<para>
Local and global variables are supported. Global variables are marked by leading underscore.
So, <command>myVar</command> is a local variable, but <command>_myVar</command> is global. The same applies
to arrays.
</para>

<screen>
a = 5
b = 2 * 5 - (a + 1)
c = "[Item " + b + "]"
d["MyKey"] = "MyValue"
d["MyKey2"] = 5
</screen>

<para>
Using variables for widgets works much as you would expect. This is usful when looping widgets inot a table.
</para>

<screen>
for i=0 to 10 do
  mycombo = "ComboTable"+i
  createWidget(mycombo, "ComboBox", "Form1")
end
</screen>

</sect1>
<sect1 id="globals">
<title>Built in Globals</title>
<para>
Kommander has some built in globals you may find handy.
</para>
<itemizedlist>
<listitem>
<command>_ARGS</command> - the argument string passed to the dialog on opening 
</listitem>
<listitem>
<command>_ARGCOUNT</command> - the count of arguments passed. These can be retrieved as <command>ARG1</command> to <command>ARGn</command> where n is the total number of args passed
</listitem>
<listitem>
<command>_KDDIR</command> - the direcotry from which the dialog was run. Kommander will default to your home directory, or a directory change if asked for it's current directory. This is useful for saving and reading files with the Kommander file.
</listitem>
<listitem>
<command>_NAME</command> - there is no reason to use this so don't
</listitem>
<listitem>
<command>_PID</command> - the process id the current dialog is being run from - also available as just <emphasis>pid</emphasis> Avoid using this name for your vairables!
</listitem>
<listitem>
<command>_VERSION</command> - this is handy if you want to display the version of Kommander that is running
</listitem>
</itemizedlist>
</sect1>
<sect1 id="passargs">
<title>Passing arguments in Kommander</title>
<para>You can pass argements via script parameters, signals and slots, command line parameters and DCOP. Let's look at scripts. Call your script like so.
<screen>result = ScriptObject1.execute("Hello World")
debug(result)</screen>
Inside your script you might have the following
<screen>var = str_upper(Self.Item(0))
return(var)</screen> 
Now you will get a return in your <emphasis>Stderr</emphasis> message log of <emphasis>HELLO WORLD</emphasis>
</para>
<para>Receiving a signal connected to a script slot works the same way. <emphasis>Self.Item(0)</emphasis> is parameter one and so on. You can retrieve the count of arguments passed with <emphasis>ScriptObject.count</emphasis>.
</para>
<para>Command line parameters allow for named or unnamed aruments.Unnamed look like
<screen>kmdr-executor myprog.kmdr 100 red</screen>
Where you will find _ARG1 = 100 and _ARG2 = red. One quirk is passing strings with spaces as an argument means they need to be quoted. Using the dialog command complicates matters as the entire argument string must pass as one string, meaning in quotes.
<screen>dialog("mydialog.kmdr", 100+" \"Hello World\"")</screen>
This returns <emphasis>_ARG1 = 100</emphasis> and <emphasis>_ARG2 = Hello World</emphasis>. Without the escaped quotes you would have <emphasis>_ARG2 = Hello</emphasis> and <emphasis>_ARG3 = World</emphasis>. Using Named Parameters is rather nice and potentially less confusing.
<screen>dialog("mydialog.kmdr", "xcount=100 xquote=Hello world")</screen>
And now you access those with <emphasis>_xcount</emphasis> and <emphasis>_xquote</emphasis>
</para>
<para>
DCOP can be complex, which is why we recommend using the tools we develop to enable creating DCOP for remote Kommander dialogs with something like a function browser. Here is an example DCOP call issued from a dialog opened from a parent Kommander window. Since it knows who its parent is it can send information back while it is open and freely access all its parent's functionality with the exception of slots. Of course that can be done internally with a script which can be called externally, so in practice there is no limit to what can be done.
<screen>dcop("kmdr-executor-"+parentPid, "KommanderIf", "setText(QString,QString)", "StatusBar8", "Hello")</screen>
Let's look at this piece by piece. First of all we add <emphasis>parentPid</emphasis> to "kmdr-executor-" as we make no assumption a Kommander window was the caller. You could use this with Quanta or KSpread or whatever. Next we are addressing <emphasis>KommanderIf</emphasis>, which is a <emphasis>nice</emphasis> interface for end users which has been cleaned up. We hope eventually as KDE moves from DCOP to DBUS on KDE4 that more applications adopt a nice interface for integration. The next paramter, <emphasis>"setText(QString,QString)"</emphasis> is important because it <emphasis>prototypes</emphasis> the parameters allowed. Otherwise Kommander could not validate the call and could crash. So without a definition of the DCOP call being used you will get an error. The remaining parameters are of course what is being passed. We recommend you look at applications with kdcop to see how this works and practice dcop calls from the shell to get your syntax right.
</para>
</sect1>
</chapter>

<chapter id="commands">
<title>Commands</title>
<para>
Various structure commands are supported. They can be freely nested.
</para>

<para>
There are also three special commands: <command>exit</command>, <command>break</command> and <command>continue</command>.
The first one ends script execution and returns. The second exits current block (<link linkend="while">while</link>,
<link linkend="for">for</link> or <link linkend="foreach">foreach</link> and the third exits just a current step, restarting
from the beginning of the loop.
</para>


<sect1 id="if">
<title>if</title>
<para>
Command <command>if</command> has following syntax:
</para>
 
<para>
<command>if</command> <emphasis>condition</emphasis> <command>then</command>
<emphasis>code</emphasis> <command>elseif</command> <emphasis>condition</emphasis> 
<command>then</command> <emphasis>code</emphasis> <command>else</command>
<emphasis>code</emphasis> <command>endif</command>
</para>

<para>
Both <command>elseif</command> and <command>else</command> parts are optional. <emphasis>Condition</emphasis>
is any expression. <emphasis>Code</emphasis> is executed if condition is true. That means:
<itemizedlist>
<listitem>non-zero for integers and double</listitem>
<listitem>non-empty for strings</listitem>
</itemizedlist>
</para>

<screen>
if a * 2 &ge; 7 then
   b = 1
elseif a &le; 0 then
   b = 2
elseif 
   b = 0
endif
</screen>
</sect1>

<sect1 id="while">
<title>while</title>
<para>
<command>while</command> <emphasis>condition</emphasis> <command>do</command>
<emphasis>code</emphasis> <command>end</command> 
</para>

<para>
<emphasis>Condition</emphasis> is recalculated each time loop is executed.
<screen>
while i &le; 15 do
  i = i + a
end  
</screen>
</para>


</sect1>

<sect1 id="for">
<title>for</title>
<para>
Command <command>for</command> has following syntax:
</para>
 
<para>
<command>for</command> <emphasis>variable</emphasis> <command>=</command>
<emphasis>start value</emphasis> <command>to</command> <emphasis>end value</emphasis> 
<command>step</command> <emphasis>expression</emphasis> <command>do</command>
<emphasis>code</emphasis> <command>end</command>
</para>

<para>
Loop is executed starting from <emphasis>start value</emphasis> and it is ended when variable's value is 
bigger then <emphasis>end value</emphasis>. If <command>step</command> part is specified, on each step
variable's value is increased by given value instead of <command>1</command>.
<screen>
foreach i = 1 to 20 step 5 do
  a = a + 2 * i
end  
</screen>
</para>
</sect1>

<sect1 id="foreach">
<title>foreach</title>
<para>
Command <command>foreach</command> has following syntax:
</para>
 
<para>
<command>for</command> <emphasis>variable</emphasis> <command>in</command>
<emphasis>array</emphasis> <command>do</command>
<emphasis>code</emphasis> <command>end</command>
</para>

<para>
Loop is executed for each key in given array. In each step variable is assigned the next key from the array.

<screen>
sum = 0
foreach i in myArray do 
  sum = sum + myArray[i]
end  
</screen>
</para>
</sect1>
</chapter>

<chapter id="functions">
<title>Functions</title>
<para>
Most old parser functions are supported by new parser. Also, some new functions were added.
</para>


<sect1 id="string_functions">
<title>String functions</title>
String functions are the same as in old parser, the only difference is that their names
are preceeded by <command>str_</command> instead of <command>@String.</command>

<itemizedlist>
<listitem>
<command>str_length(<emphasis>string</emphasis>)</command> - returns length of <emphasis>string</emphasis>
</listitem>
<listitem>
<command>str_contains(<emphasis>string</emphasis>, <emphasis>text</emphasis>)</command> - returns 1 if <emphasis>string</emphasis> contains <emphasis>text</emphasis>
</listitem>
<listitem>
<command>str_find(<emphasis>string</emphasis>, <emphasis>text</emphasis>, <emphasis>start</emphasis>)</command> - returns position of the first occurence of <emphasis>text</emphasis> in <emphasis>string</emphasis>; optional <emphasis>start</emphasis>
 specifies start of the search
</listitem>
<listitem>
<command>str_find(<emphasis>string</emphasis>, <emphasis>text</emphasis>, <emphasis>start</emphasis>)</command> - returns position of the last occurence of <emphasis>text</emphasis> in <emphasis>string</emphasis>; optional <emphasis>start</emphasis>
 specifies start of the search
</listitem>
<listitem>
<command>str_left(<emphasis>string</emphasis>, <emphasis>count</emphasis>)</command> - returns first <emphasis>count</emphasis> characters of <emphasis>string</emphasis>
</listitem>
<listitem>
<command>str_right(<emphasis>string</emphasis>, <emphasis>count</emphasis>)</command> - returns last <emphasis>count</emphasis> characters of <emphasis>string</emphasis>
</listitem>
<listitem>
<command>str_right(<emphasis>string</emphasis>, <emphasis>start</emphasis>, <emphasis>count</emphasis>)</command> - returns substring of <emphasis>string</emphasis> starting from <emphasis>start</emphasis> and containing <emphasis>count</emphasis>
characters (or everything to the end of the string if last parameter is not specified)
</listitem>
<listitem>
<command>str_remove(<emphasis>string</emphasis>, <emphasis>text</emphasis>)</command> - returns <emphasis>string</emphasis> with all substrings equal to <emphasis>text</emphasis> removed
</listitem>
<listitem>
<command>str_replace(<emphasis>string</emphasis>, <emphasis>text</emphasis>, <emphasis>text2</emphasis>)</command> - returns <emphasis>string</emphasis> with all substrings equal to <emphasis>text</emphasis> replaced with <emphasis>text2</emphasis>
</listitem>
<listitem>
<command>str_lower(<emphasis>string</emphasis>)</command> - returns <emphasis>string</emphasis> converted to lowercase
</listitem>
<listitem>
<command>str_upper(<emphasis>string</emphasis>)</command> - returns <emphasis>string</emphasis> converted to uppercase
</listitem>
<listitem>
<command>str_section(<emphasis>string</emphasis>, <emphasis>separator</emphasis>, <emphasis>start</emphasis>,
<emphasis>end</emphasis>)</command> - returns substring containing appropriate sections of <emphasis>string</emphasis> determined 
by <emphasis>separator</emphasis>; if no <emphasis>end</emphasis> is given, single <emphasis>start</emphasis> section is returned
</listitem>
<listitem>
<command>str_args(<emphasis>string</emphasis>, <emphasis>...</emphasis>)</command> - returns <emphasis>string</emphasis> with <command>%1</command>, <command>%2</command>, <command>%3</command> replaced with following parameters.
</listitem>
<listitem>
<command>str_isnumber(<emphasis>string</emphasis>)</command> - returns 1 if <emphasis>string</emphasis> is a valid number
</listitem>
<listitem>
<command>str_isempty(<emphasis>string</emphasis>)</command> - returns 1 if <emphasis>string</emphasis> is empty
</listitem>
<listitem>
<command>str_toint(<emphasis>string</emphasis>, <emphasis>default</emphasis>)</command> - returns <emphasis>string</emphasis> converted to integer; if conversion is not possible, optional <emphasis>default</emphasis> value is returned
</listitem>
<listitem>
<command>str_todouble(<emphasis>string</emphasis>, <emphasis>default</emphasis>)</command> - returns <emphasis>string</emphasis> converted to double; if conversion is not possible, optional <emphasis>default</emphasis> value is returned
</listitem>
</itemizedlist>
</sect1>

<sect1 id="kommander_functions">
<title>Kommander functions</title>
<para>
Most Kommander functions are supported; some (such as <command>expr</command>)
were obsoleted by new parser and are not available.
</para>

<itemizedlist>
<listitem>
<command>debug(<emphasis>string</emphasis>, <emphasis>...</emphasis>)</command> - writes all parameters on stderr
</listitem>
<listitem>
<command>echo(<emphasis>string</emphasis>, <emphasis>...</emphasis>)</command> - writes all parameters on stdout
</listitem>
<listitem>
<command>dcop(<emphasis>string</emphasis>, <emphasis>...</emphasis>)</command> - calls DCOP function
</listitem>
<listitem>
<command>exec(<emphasis>string</emphasis>, <emphasis>shell</emphasis>)</command> - executes external program
(using optional <emphasis>shell</emphasis>); returns output of that program
</listitem>
<listitem>
<command>i18n(<emphasis>string</emphasis>)</command> - marks <emphasis>string</emphasis> for future translation
</listitem>
<listitem>
<command>env(<emphasis>string</emphasis>)</command> - returns a value of environmental variable
</listitem>
<listitem>
<command>readSetting(<emphasis>key</emphasis>, <emphasis>default</emphasis>)</command> - returns a value stored in config
file with given <emphasis>key</emphasis>; if there is no such value <emphasis>default</emphasis> is returned
</listitem>
<listitem>
<command>writeSetting(<emphasis>key</emphasis>, <emphasis>value</emphasis>)</command> - writes pair
<emphasis>key</emphasis> and <emphasis>value</emphasis> in config file
</listitem>
</itemizedlist>
<para>New in Kommander 1.3</para>
<itemizedlist>
<listitem>
<command>return(<emphasis>value</emphasis>)</command> - returns a value to the calling object (script, button...)
</listitem>
<listitem>
<command>createWidget(<emphasis>widget name</emphasis>, <emphasis>widget type</emphasis>, <emphasis>parent</emphasis>)</command> - creates a new widget. You can then use <command>mywidget.show(true)</command> or place it in a table or toolbox. If you are putting an new widget on the form you need to consider layout issues. Kommander will not create layouts on the fly or edit pixel by pixel postioning (in most cases). This is confusing even in C++ development. We recommend you use a groupbox and do a layout in the dialog
for best control.
</listitem>
<listitem>
<command>connect(<emphasis>sender</emphasis>, <emphasis>signal</emphasis>, <emphasis>receiver</emphasis>, <emphasis>slot</emphasis>)</command> - connect a widget signal to a widget slot. See the connection dialog and select similar widgets for possibilities. If for instance a signal looks like looks like <command>execute(const QString&amp;)</command> that is exactly what must be in quotes there.
</listitem>
<listitem>
<command>disconnect(<emphasis>sender</emphasis>, <emphasis>signal</emphasis>, <emphasis>receiver</emphasis>, <emphasis>slot</emphasis>)</command> - undo the connection as listed above. Again, exact syntax is essential.
</listitem>
<listitem>
<command>widgetExists(<emphasis>widget name</emphasis>)</command> - remember you can use a variable name to reference a widget now. Us this when accessing created widgets to insure they are there. Calling a non-existant widget obviously will throw an error.
</listitem>
</itemizedlist>
</sect1>  

<sect1 id="array_functions">
<title>Array functions</title>
<para>
Most array functions are supported; some (such as <command>value</command>)
were obsoleted by new parser and are not available. The only difference is that their names
are preceeded by <command>array_</command> instead of <command>@Array.</command>
</para>

<warning>Due to parser limitation, name of array has to be specified as string now; for example
<command>array_count("MyArray")</command>.</warning>

<itemizedlist>
<listitem>
<command>array_clear(<emphasis>array</emphasis>)</command> - removes all elements from <emphasis>array</emphasis>
</listitem>
<listitem>
<command>array_count(<emphasis>array</emphasis>)</command> - returns number of elements in <emphasis>array</emphasis>
</listitem>
<listitem>
<command>array_keys(<emphasis>array</emphasis>)</command> - returns string containing EOL-separated keys of <emphasis>array</emphasis> - note that if you had imported a scalar (keys without values) into an array with Kommander you would not be able to access it with <command>array_values("myarray")</command> as you might think (since it seems to only have values) but would instead need to use <emphasis>array_keys()</emphasis> You might find a better choice for this is to use the new <emphasis>indexed arrays</emphasis> described below.
</listitem>
<listitem>
<command>array_values(<emphasis>array</emphasis>)</command> - returns string containing EOL-separated values of <emphasis>array</emphasis>
</listitem>
<listitem>
<command>array_tostring(<emphasis>array</emphasis>)</command> - returns string containing whole <emphasis>array</emphasis> 
as EOL-separated pairs containing key and value separated with TAB character
</listitem>
<listitem>
<command>array_fromstring(<emphasis>array</emphasis>, <emphasis>string</emphasis>)</command> - reads array from <emphasis>string</emphasis> (usually provided by <command>array_tostring</command> function)
</listitem>
<listitem>
<command>array_remove(<emphasis>array</emphasis>, <emphasis>key</emphasis>)</command> - removes item with key
<emphasis>key</emphasis> from <emphasis>array</emphasis>
</listitem>
</itemizedlist>
<para>New in Kommander 1.3</para>
<itemizedlist>
<listitem>
<command>array_indexedFromString(<emphasis>array</emphasis>, <emphasis>string</emphasis>, <emphasis>separator</emphasis>)</command> - this compensates for Kommander not having indexed arrays. it creates an array with a zero based sequential index. Remember to use quotes on the array name and any strings not represented by a variable. The separatore argument is optional and defaults to "\t" [TAB] which is used to separate fields reading and writing tables, arrays or detail widgets. <emphasis>Remember this array index does not enforce any rules on its self. It is just like you created it with a for loop, just more convenient.</emphasis>
</listitem>
<listitem>
<command>array_indexedInsertElements(<emphasis>array</emphasis>, <emphasis>key</emphasis>, <emphasis>string</emphasis>, <emphasis>separator</emphasis>)</command> - this function is part of the indexed array suite and enables you to insert elements in your array  while maintaining an index that is sequential, contiguous and unique. Set the index key to start at and the text string and how it is separated. The elements will be added shifting all the index numbers after by the number added.
</listitem>
<listitem>
<command>array_indexedRemoveElements(<emphasis>array</emphasis>, <emphasis>key start</emphasis>, <emphasis>number</emphasis>)</command> - this enables you to remove elements from an indexed array and avoid gaps in your index. Specify the key to start at and optionally how many to remove. The default is one. You will end up with a re-indexed array less the removed elements.
</listitem>
<listitem>
<command>array_indexedToString(<emphasis>array</emphasis>, <emphasis>separator</emphasis>)</command> - this enables you to convert your indexed array back into a string, particularly useful for detail widgets. For instance if you are displaying a database query result in TreeWidget1 and it has six columns you can use <command>TreeWidget1.selection</command> to get the selected row. it will be separated by tabs and you could look at a the fifth element by using <command>str_section(TreeWidget1.selection, "\t", 4)</command> (remember it is zero based). That's nice for reading a value, but if you want to change it you can see you have a lot more work to do. After you split that string you have to reassmble with <command>val1+"\t"+val2...</command> Using indexed arrays you could edit that fifth element like so...
<screen>
idx = TreeWidget1.currentItem
array_indexedFromString("z", TreeWidget1.selection)
z[4] = "new value"
TreeWidget1.removeItem(idx)
TreeWidget1.insertItem(array_indexedToString("z"), idx)
</screen>
Note that only two short lines were added to accomplish this! This was very welcome for database use.
</listitem>
</itemizedlist>
</sect1>  


<sect1 id="file_functions">
<title>File functions</title>
<para>
All file functions are supported, the only difference is that their names
are preceeded by <command>file_</command> instead of <command>@File.</command>
</para>

<itemizedlist>
<listitem>
<command>file_read(<emphasis>name</emphasis>)</command> - returns content of file <emphasis>name</emphasis>
</listitem>
<listitem>
<command>file_write(<emphasis>name</emphasis>, <emphasis>...</emphasis>)</command> - writes all arguments
to file <emphasis>name</emphasis>
</listitem>
<listitem>
<command>file_append(<emphasis>name</emphasis>, <emphasis>...</emphasis>)</command> - appends all arguments
to file <emphasis>name</emphasis>
</listitem>
</itemizedlist>
</sect1>  

  
<sect1 id="input_functions">
<title>Input functions</title>
<para>
These functions show some dialog allowing user to enter some value. Now they work only in new parser, but they will be probably backported to old parser at some point. For most functions all parameters are optional, exception is
<command>input_text</command> which requires 2 parameters and  <command>input_value</command> which requires 5 parameters.
</para>

<itemizedlist>
<listitem>
<command>input_color(<emphasis>caption</emphasis>, <emphasis>default</emphasis>)</command> - returns color in #RRGGBB format
</listitem>
<listitem>
<command>input_text(<emphasis>caption</emphasis>, <emphasis>label</emphasis>, <emphasis>default</emphasis>)</command> - returns text entered by user
</listitem>
<listitem>
<command>input_value(<emphasis>caption</emphasis>, <emphasis>label</emphasis>, <emphasis>default</emphasis>, 
<emphasis>min</emphasis>, <emphasis>max</emphasis>, <emphasis>step</emphasis>)</command> - returns value entered by user
</listitem>
<listitem>
<command>input_directory(<emphasis>startdir</emphasis>, <emphasis>filter</emphasis>, <emphasis>caption</emphasis>)</command> - returns directory selected by user
</listitem>
<listitem>
<command>input_openfile(<emphasis>caption</emphasis>, <emphasis>label</emphasis>, <emphasis>default</emphasis>)</command> - returns existing file entered by user
</listitem>
<listitem>
<command>input_savefile(<emphasis>caption</emphasis>, <emphasis>label</emphasis>, <emphasis>default</emphasis>)</command> - returns file entered by user (if file exists, confirmation will be required)
</listitem>
<listitem>
<command>input_openfiles(<emphasis>caption</emphasis>, <emphasis>label</emphasis>, <emphasis>default</emphasis>)</command> - returns string of EOL-separated existing files entered by user
</listitem>
</itemizedlist>
</sect1>  


<sect1 id="message_functions">
<title>Message functions</title>
<para>
These functions show some message for user or ask user to confirm some action. Now they work only in new parser, but they will be probably backported to old parser at some point. Only the first parameter is required.
</para>

<itemizedlist>
<listitem>
<command>message_info(<emphasis>text</emphasis>, <emphasis>caption</emphasis>)</command> - shows information text
</listitem>
<listitem>
<command>message_error(<emphasis>text</emphasis>, <emphasis>caption</emphasis>)</command> - shows error text
</listitem>
<listitem>
<command>message_warning(<emphasis>text</emphasis>, <emphasis>caption</emphasis>, <emphasis>button1</emphasis>, 
<emphasis>button2</emphasis>, <emphasis>button3</emphasis>)</command> - shows question with warning and up to three buttons; number 
of chosen button is returned; if no button names are specified, <command>Yes</command> and <command>No</command> will be displayed
</listitem>
<listitem>
<command>message_question(<emphasis>text</emphasis>, <emphasis>caption</emphasis>, <emphasis>button1</emphasis>, 
<emphasis>button2</emphasis>, <emphasis>button3</emphasis>)</command> - shows question and up to three buttons; number 
of chosen button is returned; if no button names are specified, <command>Yes</command> and <command>No</command> will be displayed
</listitem>
</itemizedlist>
</sect1>  
</chapter>
</book>


